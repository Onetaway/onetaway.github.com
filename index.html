
<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>Coding is Art</title>
	<meta name="author" content="Onet away">

	
	<meta name="description" content="读书笔记 | Comments 《结网》 读书笔记 写在前面—Developers need to know > what you thought 辞职后，就想要做一款供程序员用起来舒服的 GitHub 客户端，其实我的最开始的初衷只是想实现 GitHub 上的 contributions &hellip;&#8221;>
	

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="/atom.xml" rel="alternate" title="Coding is Art" type="application/atom+xml">
	
	<link rel="canonical" href="http://Onetaway.github.io/">
	<link href="/favicon.png" rel="shortcut icon">
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
	<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,400,700' rel='stylesheet' type='text/css'>
	<!--Fonts from Google"s Web font directory at http://google.com/webfonts -->


</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
			<header id="header" class="inner"><div class="profilepic">	
	<script src="/javascripts/md5.js"></script>
	<script type="text/javascript">
		document.write("<img src='/images/profile.png' alt='Profile Picture' style='width: 160px;' />");
	</script>
</div>
<h1><a href="/">Coding is Art</a></h1>
<p class="subtitle">写 给人阅读的代码</p>
<nav id="main-nav"><ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>
</nav>
<nav id="sub-nav">
	<div class="social">
		
		<a class="weibo" href="http://www.weibo.com/onetaway" title="Weibo">Weibo</a>
		
		
		
		<a class="google" href="https://plus.google.com/112430088622939472702/posts" rel="author" title="Google+">Google+</a>
		
		
		<a class="twitter" href="http://twitter.com/Onetaway" title="Twitter">Twitter</a>
		
		
		<a class="github" href="https://github.com/Onetaway" title="GitHub">GitHub</a>
		
		
		
		
		
		
		
		<a class="rss" href="/atom.xml" title="RSS">RSS</a>
		
	</div>
</nav>
<hgroup>
  <h1><a href="/">Coding is Art</a></h1>
  
    <h2>写 给人阅读的代码</h2>
  
</hgroup>

</header>				
			</div>
		</div>	
		<div class="mid-col">
			
				
			
			<div class="mid-col-container">
				<div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-09-28T11:48:12+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/du-shu-bi-ji/'>读书笔记</a>


</div>
		
		
          | <a href="/blog/2014/09/28/%3C%3Cjie-wang-%3E%3E-du-shu-bi-ji/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/09/28/%3C%3Cjie-wang-%3E%3E-du-shu-bi-ji/" itemprop="url">《结网》 读书笔记</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>写在前面—Developers need to know > what you thought</h2>

<p>辞职后，就想要做一款供程序员用起来舒服的 GitHub 客户端，其实我的最开始的初衷只是想实现 GitHub 上的 contributions 的绿色小方块，让程序员们在 iPhone 上也能有这样美好的体验，让程序员在年底晒 GitHub 的时候更方便更有意思，而且也想使用 Swift 练练手。于是，我就想了既然这个都做了，那不如就做一个完整的客户端吧，真是逼(no)格(zuo)尽(no)显(die)。</p>

<p>于是乎，就干起来了。但是当我真的要着手的时候，发现完全无从下手啊。那一刻，我才明白程序员要会的不仅仅是写程序，于是，我就谷歌、知乎各种刷，终于，我发现了一本适合产品经理入门，并且大家觉得都还不错的书——《结网》。于是，我就花了一天时间，基本算翻完了。我也确实觉得写的不错，遂，写此读书笔记，和大家一起聊聊 beyond the develop 的故事。</p>

<h2>正文</h2>

<p>以前我一直觉得，角色应该各司其职，产品经理就应该专注产品，设计师就应该专注设计，程序员就应该专注写程序。但是，现实根本不是这样。这点在移动端 App 上更加明显。一个程序员某一天突然有了一个 idea，于是乎就很想把它实现，这个时候，他就完全充当了上述三个人的角色。我们同样也知道，现在有很多 iOS 独立开发者，他们的设计等等也都是自己做的。因此，我觉得一个合格的移动端开发者应该具备的素质有：构建产品的能力，基本的设计能力，编码能力。下面，我就说说我认为开发者应该具备产品经理素质的具体表现。</p>

<h3>产品设计文档</h3>

<p>程序员需要能够画出产品设计文档，包括：<strong>结构图</strong>、<strong>线框图</strong>和<strong>描述表</strong>。</p>

<p><strong>结构图</strong>描述了整个程序的结构以及模块划分，可以使用思维导图工具(比如：MindManager等)进行创作。描述结构图的时候需要注意 <code>MECE原则</code>(读作：me-see)，是 Mutually Exclusive Collectively Exhaustive 的缩写。意思就是<code>相互独立，完全穷尽</code>。繁杂的信息经过 MECE原则处理后，呈现出分类清晰并且穷尽的结果，降低了理解成本。思维导图示例如下：</p>

<p><img alt="思维导图" src="https://github.com/Onetaway/onetaway.github.com/blob/source/source/images/mindPicture.png"></p>

<p>明确了结构之后，我们就需要细化每个页面了，这里我们要使用的是线框图。<strong>线框图</strong>描述了一个程序中所需要包含的基础元素及其在这个界面中的布局。线框图的制作工具也很多，比如 Axure 等等，线框图示例如下。画完了线框图，我们就需要描述表了。</p>

<p><img alt="线框图" src="https://github.com/Onetaway/onetaway.github.com/blob/source/source/images/wireFrame.png"></p>

<p><strong>描述表</strong>只包含一个界面中需要展示的元素和背后的逻辑，并<em>不</em>包含这些元素在页面中的布局。它的主要好处有二：第一，将你要显示的元素和元素的布局分割开来；第二、向开发人员讲述背后的逻辑，便于开发实现。</p>

<p>优秀的产品设计文档应该具备以下特性：</p>

<ol>
<li>保持简短。保持简短的重要手段是将需求与非需求分离。保持需求的简短，将非需求的部分放到图表、附录或者 FAQ 中。</li>
<li>尽可能地消灭错误。可以使用 Wiki 写文档。</li>
<li>别对他人(主要指研发人员)的工作指手画脚。</li>
<li>用适当的表述方式展现需求。比如，如果用文字说不清楚，那就用表格做解释。</li>
<li>使用肯定、明确的词语。不要出现“也许”、“可能”这样的词语。</li>
</ol>


<h3>关注用户体验</h3>

<p>记住一句话：用户体验影响产品口碑，产品口碑影响产品成败。
从哪些方面关注用户体验，记住“三个不要”：</p>

<ul>
<li>不要让我等</li>
<li>不要让我想</li>
<li>不要让我烦</li>
</ul>


<p>这就是我觉得最重要的几点了，起身走近窗户，九月桂花分外香。</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-09-18T15:33:15+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/fan-yi/'>翻译</a>


</div>
		
		
          | <a href="/blog/2014/09/18/apishe-ji/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/09/18/apishe-ji/" itemprop="url">API设计</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<h2>API设计</h2>

<p>本文翻译自 Matt Gemmell 的经典博文，想阅读英文原版的同学请直接点击<a href="http://mattgemmell.com/api-design/">这里</a>。下面开始正文内容。</p>

<p>我在开发中做的最多的一件事就是为可重用的组件设计 API。这些组件通常都是给 iOS 用的(尽管有时候，它们也适用于 OS X)，通常是 GUI 控件或者是某种视图。</p>

<p>这些年我设计了许多组件 API，包括像苹果的客户端，因此我学到了很多这方面的东西。我也定期发布<a href="http://mattgemmell.com/source/">开源组件</a>，我收到的反馈帮助我形成了 API 设计的准则，我想与你们分享这些。</p>

<p>这是一个重要的话题，无论你是一个开源软件的贡献者，还是一个工作在大型项目团队里的成员，或者你仅仅是编写自己的软件。就像第一次启动应用程序的经历一样，你的 API 会给使用你代码的开发者留下第一印象，这会在很大程度上决定他们是使用你的 API 还是直接扔掉。</p>

<p>in a way that’s specific to the popular platforms.</p>

<p>API 是开发者的用户体验(UX)。令我惊讶的是，在这方面没有很多资料。</p>

<p>我打算使用我最新发布的开源 GUI 组件 <a href="http://mattgemmell.com/mgtilemenu/">MGTileMenu</a> 作为例子，来介绍这些原则。如果你喜欢的话，你可以在<a href="http://mattgemmell.com/mgtilemenu/">这里</a>阅读关于 MGTileMenu 的一切东西。</p>

<h3>理想的状态</h3>

<p>API 设计和用户界面以及用户体验设计非常相似。你的目标听众具有不同的需求和特性，但是归根到底他们也只是希望把事情完成的人。除了友好的、可用的 app UI，你还需要尽力让你的 API：</p>

<ol>
<li>直观的</li>
<li>宽容的</li>
<li>光滑的</li>
</ol>


<p>因为软件的任何一部分都是设计给人使用的，所以我们不得不考虑用例。我们必须要让需要经常做的事情变得简单，同时没有过多的配置。默认的行为应该和原来一样有用，且容易选择。软件应该是可发现的，并且应该允许用户从已知的范式中生成新的东西。这些准则和我们在创建 UI 的时候是一样的</p>

<h3>开发者的接口</h3>

<p>开发者和组件打交道主要是通过下面这四个显示的方式：</p>

<ol>
<li>类<strong>接口</strong>：它揭示了属性和方法。</li>
<li>相关的<strong>代理协议</strong></li>
<li>合适的<strong>数据源协议</strong></li>
<li>已提供的<strong>通知</strong></li>
</ol>


<p>我们必须明智且审慎地设计这些。当你在思考 API 的时候，有两个关键的问题：</p>

<ul>
<li>控件是什么？</li>
</ul>


<p>这影响着接口和便捷方法。它是一个按钮？或者是一个滚动条？你的接口是很明显的。你的便捷方法将会遵循控件的标准语意。</p>

<ul>
<li>控件像什么？</li>
</ul>


<p>这影响着代理、数据源模型以及通知。如果它是一种新的控件，那它本质上有和其他控件相似的地方么？一个大纲视图是一个线性表。一个日历小工具是一个日期选择器。命令的集合以统一的表现形式显示在菜单栏里。</p>

<p>我们的核心目标是同现有的组件和模型保持一致，只有这样，我们才能将不熟悉的控件转换为开发者已经熟知的东西。尽量在任何地方使用标准的 API，模型和模式。熟悉感和直觉在代码级的重要性与在用户级的重要性一样。</p>

<p>让我们看一下上面提到的组件 API 中的四个要素。</p>

<h3>类的接口</h3>

<p>这里是 <a href="https://github.com/mattgemmell/MGTileMenu/blob/master/MGTileMenu/MGTileMenuController.h">MGTileMenu 的接口文件</a>。</p>

<p>在我们开始讨论特定的接口之前，我们先来看看一些重要的准则。</p>

<h2>准则1：使用本平台语言</h2>

<p>在 API 设计中我见到的最普遍的错误是使用<em>其他平台的习惯</em>。API 属于一个平台和一个开发者生态系统。你不能使用你曾经熟悉的与本平台不同的平台的习语和架构，那样做，只会污染你当前的代码，并且降低后继开发者生产力。</p>

<p>Learn your target platform’s conventions before coding. For example, on iOS or OS X, don’t use exceptions for control flow. Name your methods in an appropriate manner (which usually means sufficiently verbose, but should also of course be sufficiently succinct).</p>

<p>Learn what a protocol is, and a delegate, and a category. Use that terminology throughout your code. Learn the relevant naming schemes for constructors and destructors. Obey native memory management rules. The vocabulary and the grammar are indivisible, and you’re either developing for a given platform or you’re not.</p>

<p>Rule 2: Design decoupled</p>

<p>Any component should be designed such that it’s not coupled to the project you created it for, and if it’s a GUI control or view, it should at least display something by default. Use the existing framework classes as a guide, and maintain loose coupling with delegate protocols, well-designed/named API methods and notifications where appropriate.</p>

<p>An obvious but very effective way to do this is to create a new project for each component, and develop the component literally in isolation. Force yourself to use your own API. Stay away from the temptation of tying unrelated classes together. Start as you mean to go on.</p>

<p>With that said, let’s talk about the class interface proper. Initialisation methods are one of the most important parts of the interface, because they’re how people get started with your component. Your class will have certain required settings for initial configuration. So, an obvious rule:</p>

<p>Rule 3: Required settings should be initializer parameters</p>

<p>If something needs to be set, don’t wait for it - require it up-front, immediately, and return nil if you don’t get something acceptable.</p>

<p>1
- (id)initWithDelegate:(id<MGTileMenuDelegate>)theDelegate; // required parameter; cannot be nil.
Rule 4: Allow access to initializer parameters</p>

<p>This is a corollary to the previous rule: remember not to just swallow those parameters. Give access to them via properties, and note if they might have been massaged in any way (sanitised, or otherwise modified).</p>

<p>1
@property (nonatomic, weak, readonly) id<MGTileMenuDelegate> delegate; // must be specified via initializer method.
These previous two examples raise a further general point.</p>

<p>Rule 5: Comment your header files (including defaults)</p>

<p>Realistically, you won’t always provide separate, standalone documentation for a component. If you don’t provide documentation, your .h files (and demo app) are your docs. They should be suitably written, and by ‘suitably’ I mean:</p>

<p>Sufficiently detailed, but no more so. Be succinct.
For professionals. Assume things that are safe to assume. Don’t waffle.
Particularly, you should briefly note default values beside properties or accessors; it’s much easier to scan those in the header file than to try to locate your initialisation code in the implementation.</p>

<p>1
2
3
@property (nonatomic) CGGradientRef tileGradient; // gradient to apply to tile backgrounds (default: a lovely blue)
@property (nonatomic) NSInteger selectionBorderWidth; // default: 5 pixels
@property (nonatomic) CGGradientRef selectionGradient; // default: a subtle white (top) to grey (bottom) gradient
Rule 6: Get up and running in 3 lines</p>

<p>Your class should be designed so that it requires minimal code to integrate (delegate/data-source protocol included, about which more later). Excluding delegate methods, you should aim to make it usable at least for testing purposes with only 3 lines of code.</p>

<p>Those lines are:</p>

<p>Instantiate it.
Basically configure, so it will show and/or do something.
Display or otherwise activate it.
That should be it. Anything substantially more onerous is a code smell. Here are the relevant lines from MGTileMenu’s demo app:</p>

<p>1
2
3
4
5
6
7
8
// Instantiate.
tileController = [[MGTileMenuController alloc] initWithDelegate:self];</p>

<p>// Configure.
tileController.dismissAfterTileActivated = NO; // to make it easier to play with in the demo app.</p>

<p>// Display.
[tileController displayMenuCenteredOnPoint:loc inView:self.view];
Rule 7: A fat demo usually means a broken component</p>

<p>Another corollary: the size of your demo harness is a quality metric for your component, where smaller is better. Demo harnesses/code should be as small and thin as possible (making suitable allowances for demos that aim to explore all of a component’s customisation or functionality).</p>

<p>The core required code to turn an empty Xcode app template into a demo of your app should be minimised. It’s not OK to required copy-pasted boilerplate to get your component working, and having an example of it in your demo isn’t an excuse.</p>

<p>Rule 8: Anticipate customisation scenarios</p>

<p>My standard rule for apps is don’t give the user options. Choose sensible defaults to fit the majority, and skip the Preferences window. Good software, after all, is opinionated.</p>

<p>The situation is a bit different with components, because the scenarios of use aren’t as clear-cut. You can certainly make a component that only fits one specific situation, but usually we want some flexibility. You never know exactly how another developer is going to use your component, so you have to build in some generality.</p>

<p>It’s important to choose your customisation points carefully. It’s particularly important to consider dependencies - not in the compiling/linking sense, but rather the logical relationships between types of customisation. I approach this by trying not to think of customisation at the instance-variable level, but rather at the “aspect” level. What aspects of your component do you want to allow customisation of? Then you work out what specific properties to expose.</p>

<p>It’s easy to cripple a certain type of customisation by not exposing sufficient configuration points. Some examples:</p>

<p>Don’t expose width and height without considering corner radius too.
Don’t expose background colour without highlighted background colour.
Don’t expose size without spacing.
The specifics depend on the component, but just try to consider the relationships between properties, from the point of view of either appearance or functionality. Empathise with the developer. Be flexible, without abandoning the identity of the component.</p>

<p>1
2
3
4
5
6
@property (nonatomic) BOOL dismissAfterTileActivated; // automatically dismiss menu after a tile is activated (YES; default)
@property (nonatomic) BOOL rightHanded; // leave gap for right-handed finger (YES; default) or left-handed (NO)</p>

<p>@property (nonatomic) NSInteger tileSide; // width and height of each tile, in pixels (default 72 pixels)
@property (nonatomic) NSInteger tileGap; // horizontal and vertical gaps between tiles, in pixels (default: 20 pixels)
@property (nonatomic) CGFloat cornerRadius; // corner radius for bezel and all tiles, in pixels (default: 12.0 pixels)
Let common sense be your guide. Decide what options will serve 70% or so of the usage situations you can think of, and provide those options. Let your delegate methods and code structure serve the rest.</p>

<p>Rule 9: More properties, fewer actions</p>

<p>There’s a particular pattern that keeps cropping up in components that I like - some of which are from standard frameworks, some open source from third parties, and some even my own. It’s a ratio of the number of properties (or accessors, or customisation points) on a component, to the number of “do stuff” methods (i.e. all the other stuff, from initializers to state-updating).</p>

<p>It’s pretty much always more properties, and fewer ‘actions’ (again, that’s not actions in the Interface Builder sense). MGTileMenu has an initializer, and four actual for-public-use methods (one of which is a convenience that calls another). In terms of customisation points, it has four times as many. I think that’s a good ratio, and leads to components that are both concise in actual functionality, but also flexible in customisation.</p>

<p>1
2
3
4
- (id)initWithDelegate:(id<MGTileMenuDelegate>)theDelegate; // required parameter; cannot be nil.
- (CGPoint)displayMenuPage:(NSInteger)pageNum centeredOnPoint:(CGPoint)centerPt inView:(UIView *)parentView; // zero-based pageNum
- (void)dismissMenu;
- (void)switchToPage:(NSInteger)pageNum; // zero-based pageNum
Rule 10: Use controls in your controls</p>

<p>A great way to simplify both the API and implementation of your component is to use existing controls in your implementation. A unified presentation doesn’t meant that you can’t build something out of pre-existing components (indeed, that’s one of the basic principles of good software engineering).</p>

<p>Consider how UITableViewCell and UIButton have simple APIs because they use sub-controls such as UIImageViews and UILabels. You can, and should, do that too - and if appropriate, expose the corresponding sub-controls to keep your class interface concise and consistent.</p>

<p>In MGTileMenu, for example, the tiles are regular UIButtons (not even subclasses). This drastically simplified the implementation compared to drawing the tiles within a single custom view, tracking input events, and supporting accessibility.</p>

<p>Rule 11: Convenient for you is convenient for me</p>

<p>You’ll naturally add convenience methods during implementation, and the instinct is to keep them private. Instead, consider whether you can expose them for use by those who integrate your component into their own apps.</p>

<p>Whatever made it more convenient for you to add a method or function may apply to those developers too.</p>

<p>For example, in MGTileMenu I created these convenience functions:</p>

<p>1
2
3
CGRect MGMinimallyOverlapRects(CGRect inner, CGRect outer, CGFloat padding);</p>

<p>CGGradientRef MGCreateGradientWithColors(UIColor <em>topColorRGB, UIColor </em>bottomColorRGB); // assumes colors in RGB colorspace
The first helps me shift a tile menu so that it’s fully visible within its parent view (which might be handy for another developer, if they’re providing ancillary UI related to the menu), and the second returns a Core Graphics gradient from two UIColors, which I used when setting a default background for the tiles (and another developer may find handy when implementing MGTileMenu’s delegate protocol, to give tiles custom gradients).</p>

<p>Rule 12: Magic is OK. Numbers aren’t.</p>

<p>Sooner or later, you’ll put magic into your component. Hopefully there’ll be plenty of the Steve Jobs type of intuitive, delightful, empowering magic, but what I’m talking about is things like numbers and other values that have special meaning in your code. A common example is -1, to indicate a unique thing in a set, or a special situation.</p>

<p>It’s fine. It’s genuinely OK to do that. What’s not OK, though, is needlessly putting mysterious raw values throughout your code, and it’s especially not OK to expose that in the API. If you’re exposing magic, dress them up for consumption. Use #defines or a constant or something. Just make them presentable and understandable.</p>

<p>1
2
// Used for the page-switching tile in methods expecting a tile-number.</p>

<h1>define MG_PAGE_SWITCHING_TILE_INDEX -1</h1>

<p>Delegate and data-source protocols</p>

<p>Delegate protocols are fantastic. They’re an easy, familiar and flexible way to embrace the MVC pattern, and they reinforce good habits of loose coupling and judicious API design.</p>

<p>Here’s MGTileMenu’s delegate protocol.</p>

<p>There are classic delegate and data-source protocols that we can draw on for almost any component. If you’re displaying data, the One True Data-Source Protocol is likely to be something very close to:</p>

<p>How many things do I have?
What’s the value for property Y of thing X?
Similarly, in almost any situation, the One True Delegate Protocol is likely to take the form:</p>

<p>Should this thing do that?
This thing is about to do that.
This thing just did that.
This is also known as the Should, Will, Did protocol pattern, and it ties neatly in with the Will-Did notification pattern too, about which more later.</p>

<p>Let me mention something you might find controversial: I find it perfectly acceptable to conflate the delegate with the data-source (i.e. combine them into a single protocol). I do it with MGTileMenu and several other components, for example.</p>

<p>I fully accept the principle of separating them, and I can think of many cases where you’d want to keep them separate. Apple keeps them separate too, generally. That’s fine.</p>

<p>In my experience, though, in most cases it’s fine to combine them. Most people handle data-source methods and delegate methods in the same place. I’ve never had a complaint about unifying those protocols, and I can scarcely remember a situation where even existing separate protocols were handled in different places.</p>

<p>If you care about purity, or have a need to separate delegate from data-source, then obviously you should do so. I just don’t think you need to feel bad if you combine them.</p>

<p>Rule 13: Limit ‘required’ delegate methods</p>

<p>Be very careful when choosing which of your delegate methods are required. Too many required methods tends to indicate:</p>

<p>Poor choice of default behaviour.
Too much of your own politics are in your code.
A well-designed component should need very, very few required delegate methods - just the bare minimum to do whatever it does. Choose carefully. Equally, remember that it’s easy to add optional methods later, but it’s hard to turn optional ones into required ones (people will complain, and rightly so).</p>

<p>MGTileMenu has five required methods, four of which are data-source methods:</p>

<p>1
2
3
4
- (NSInteger)numberOfTilesInMenu:(MGTileMenuController <em>)tileMenu; // in total (will be shown in groups of up to 5 per page)
- (UIImage </em>)imageForTile:(NSInteger)tileNumber inMenu:(MGTileMenuController <em>)tileMenu; // zero-based tileNumber
- (NSString </em>)labelForTile:(NSInteger)tileNumber inMenu:(MGTileMenuController <em>)tileMenu; // zero-based tileNumber
- (NSString </em>)descriptionForTile:(NSInteger)tileNumber inMenu:(MGTileMenuController *)tileMenu; // zero-based tileNumber
The first two follow the One True Data-Source Protocol. The third and fourth do too, but they also expose my politics: I think that software should be accessible, and I’m forcing you to supply a label and hint for each tile for VoiceOver to read. I’m comfortable with it.</p>

<p>There’s also one delegate method proper:</p>

<p>1
- (void)tileMenu:(MGTileMenuController *)tileMenu didActivateTile:(NSInteger)tileNumber; // zero-based tileNumber
That one is required because it’s how you find out that a tile was activated. If you’re not willing to pay attention to that, MGTileMenu will do nothing useful, and you might as well not be using it at all. So, it’s required.</p>

<p>Rule 14: Design for accessibility</p>

<p>Following immediately on from the last rule: make things accessible. Don’t tack it on at the end, either: design for accessibility from the start. If you follow the “use controls in your controls” rule, you probably get this almost for free.</p>

<p>Delegate (or rather, data-source) methods, as shown above, are a great place to twist the arm of another developer to make them at least provide something for VoiceOver. And if you can automatically repurpose something visual (like a displayed text label) as a VoiceOver label, so much the better (again, in most cases VoiceOver already handles this for you).</p>

<p>Be socially conscious. Make it hard not to support accessibility. I also wrote an article about supporting VoiceOver in iOS apps, which Apple recommends to companies who contact them about accessibility programming. I recommend it too, but then I wrote it, so you’d expect that.</p>

<p>Rule 15: Use semantic objects for parameters</p>

<p>This doesn’t just apply to protocols, but protocols are where it’s particularly important. Use actual, first-class, semantically-appropriate objects for data, even if it’s more hassle for you to work with in your implementation.</p>

<p>If you’re asking for a date, don’t accept numbers - get an actual NSDate object. There are objects or structures for just about everything, and you should use them as intended. Create a class if you need to (you probably won’t need to).</p>

<p>The one standard exception, of course, is indices - there’s no reason for them to be anything but primitives, since NSNumber adds nothing that’s semantically important enough to offset the bundling/unbundling inconvenience.</p>

<p>Rule 16: Enhance the API if semantics don’t fit</p>

<p>I see this all the time. I mentioned earlier how you can think of almost any new, custom control as being substantially like something that already exists (often, it’s like the already-existing thing that you’re using behind the scenes for your implementation).</p>

<p>That’s great, and you’re very clever, but semantics trump similarity. It’s absolutely fine (and wonderful) to layer a new API on top of an existing one, in order to make the semantics fit. For example:</p>

<p>A contact list implemented with a table should have a contacts-related API
A month-view calendar implemented with a grid should have a date-related API
And so forth. Don’t force yourself (or other developers) to constantly be mentally converting between an abstract implementation API and the actual semantics of the component - make the API reflect the actual purpose of the component instead.</p>

<p>MGTileMenu’s delegate protocol does that by treating the menu not as a collection of UIButtons (the implementation), but rather as a unified menu, with numbered tiles each of which have relevant display properties.</p>

<p>Rule 17: Highlighting is interesting</p>

<p>I learned this one by having to go back and add new delegate methods and notifications to APIs I thought were finished. For interactive controls, highlighting is interesting. By ‘interesting’, I mean of potential significance to the surrounding app.</p>

<p>Any control will inform the app (in one sense or another, perhaps just by calling an action method) when it has been fully triggered, but comparatively few will notify when they’ve been visually highlighted (selected, pressed) or unhighlighted without being triggered. It turns out that that’s actually pretty important. The app might want to:</p>

<p>Add, remove or reposition ancillary UI.
Update some other part of its display.
Offer some contextual help.
Some other thing you can’t possibly foresee.
Highlighting is certainly an example of an optional set of delegate methods, but they’re important to have, and almost always trivial to implement.</p>

<p>1
2
- (void)tileMenu:(MGTileMenuController <em>)tileMenu didSelectTile:(NSInteger)tileNumber; // zero-based tileNumber
- (void)tileMenu:(MGTileMenuController </em>)tileMenu didDeselectTile:(NSInteger)tileNumber; // zero-based tileNumber
Rule 18: Optional methods aren’t a commitment</p>

<p>Many of us approach optional delegate methods as an either-or situation: if you don’t implement them, you get the default behaviour, and if you do, then you’re totally responsible for what happens. That’s not ideal.</p>

<p>In any implementation which provides an optional delegate method, you should still fall back on the default behaviour even if the method is implemented, but doesn’t return something sensible. It sounds obvious, but it’s amazing how many components will blithely let delegate objects return any kind of craziness without sanity-checking, just because the delegate has somehow promised to behave itself by implementing the method.</p>

<p>I’m talking particularly about visual customisations, such as background colours or images. Consider very, very carefully whether you shouldn’t intervene in that case, and fall back upon your default appearance. Did they really want to show nothing? Does that even make sense? Will it make the control look broken? If so, step in, and serve up the default just as if the delegate method was never implemented in the first place.</p>

<p>Relatedly, have a documented, standard, unsurprising way to deliberately invoke the default behaviour via returning something like nil from each optional delegate method.</p>

<p>MGTileMenu, for example, has a relatively complex hierarchy of ways you can customise tile backgrounds. You can implement any (or all, or none) of three optional delegate methods to provide a background image, gradient or colour for each tile, in that priority order. You can also opt into the default behaviour for any tile at any time, by returning nil or NULL as is appropriate to the type.</p>

<p>You’ll have to try fairly hard (by returning clearColor, or an empty UIImage object) to really, really make a tile’s background completely transparent.</p>

<p>Rule 19: Always say who’s talking</p>

<p>This is a simple rule, and an equally simple mistake to make. In your delegate methods, always pass the sender as a parameter. Always. Even for singletons. Even for things you cannot conceive would ever be used more than once simultaneously. No exceptions.</p>

<p>This:</p>

<p>1
- (void)tileMenu:(MGTileMenuController *)tileMenu didActivateTile:(NSInteger)tileNumber; // zero-based tileNumber
Not this:</p>

<p>1
2
- (void)tileMenuDidActivateTile:(NSInteger)tileNumber; // zero-based tileNumber
// Um, WHICH menu?
Rule 20: Put distinguishing params first in query methods</p>

<p>The One True Data-Source Protocol should always have query methods such that the most interesting thing goes first. The specific quality or property you’re requesting a value for. Like this:</p>

<p>1
- (UIImage <em>)imageForTile:(NSInteger)tileNumber inMenu:(MGTileMenuController </em>)tileMenu; // zero-based tileNumber
Not like this:</p>

<p>1
- (UIImage <em>)tileMenu:(MGTileMenuController </em>)tileMenu imageForTile:(NSInteger)tileNumber;
The return type should flow naturally into the first part of the method name, without causing surprise. Data-source protocols often have many similarly-named methods, so keep the unique and interesting parts at the very start. Easier to read, and easier to autocomplete.</p>

<p>Some people have pointed out that Apple’s UITableViewDataSource protocol doesn’t do it that way, and instead puts the sender first, for example:</p>

<p>1
- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
All I can say is: I’m aware of the difference. I stand by my argument.</p>

<p>Rule 21: Put the sender first in notification methods</p>

<p>The One True Delegate Protocol, however, isn’t for queries but rather for notifications. In this situation, you put the sender first (following our “say who’s talking” rule above).</p>

<p>1
- (void)tileMenu:(MGTileMenuController *)tileMenu willSwitchToPage:(NSInteger)pageNumber; // zero-based pageNumber
This follows how an interaction would go between two people having a conversation. You wouldn’t just jump in and say “She’s going to be late,” because the other person would have to ask “Who?”</p>

<p>Instead, you start by saying who’s talking. It’s a convention, and handily distinguishes query (data-source) from notification (delegate) methods.</p>

<p>Rule 22: If a convention is broken, throw it away</p>

<p>Having said all of the above, remember that convention and consistency must at some point bow to superior judgement - in this case, yours. If a convention is broken, skip it without worrying. Rename things, if yours is truly better.</p>

<p>As an example, there’s a pre-existing convention for menu controls whereby you can enable or disable menu-items via the delegate, using a method called validateMenuItem:. For the sake of consistency, I was tempted to use that same method name as part of my delegate protocol. I decided not to, because:</p>

<p>It has a horrible, horrible name. “Validate”? That doesn’t say “enable” to me.
It’s imperative, where in my case I’m really asking a question.
It broke the naming scheme of my other delegate methods.
Instead, I went for something simpler and more understandable, if unconventionally-named:</p>

<p>1
- (BOOL)isTileEnabled:(NSInteger)tileNumber inMenu:(MGTileMenuController *)tileMenu; // zero-based tileNumber
We can debate the specific wording, but if you encountered that method you’d know what it was for and how to use it right away. To me, that’s better.</p>

<p>Notifications</p>

<p>Notifications are the other half of delegate protocols. My position is that, if you’re using a delegate protocol (you should, if it’s at all appropriate), then it’s incomplete until you add the notifications that naturally follow from it.</p>

<p>In MGTileMenu, you can find the notifications in the interface file for MGTileMenuController.</p>

<p>Rule 23: Notifications follow delegate methods</p>

<p>There’s a natural correspondence between delegate methods (proper; not data-source methods) and notifications. You use them in the same places in your code, and for exactly the same purpose.</p>

<p>If you have a delegate method that tells the delegate about something happening, you should usually provide a notification for that same purpose. Take your notification-like delegate methods, remove the interrogatory ones (the should methods), and you have your list of notifications to implement.</p>

<p>The delegate methods’ parameters should match up with the notifications’ userInfo contents, with the obvious exception that you pass the sender as the notification’s object, rather than bundled up in the info dictionary.</p>

<p>Delegate methods:</p>

<p>1
2
- (void)tileMenuWillDisplay:(MGTileMenuController <em>)tileMenu;
- (void)tileMenuDidDisplay:(MGTileMenuController </em>)tileMenu;
And corresponding notifications:</p>

<p>1
2
extern NSString <em>MGTileMenuWillDisplayNotification; // menu will be shown
extern NSString </em>MGTileMenuDidDisplayNotification; // menu has been shown
Rule 24: Be generous with notifications’ userInfo</p>

<p>Give a notification the information it requires in order to be useful. Remember that notification receivers may (and almost always will) not have anything to do with the delegate or data-source chain for your component.</p>

<p>Ask yourself what would be useful, and provide that information. At the very least, you must ensure that all arguments provided to the corresponding delegate method are wrapped up in the userInfo object.</p>

<p>Delegate methods:</p>

<p>1
2
- (void)tileMenu:(MGTileMenuController <em>)tileMenu willSwitchToPage:(NSInteger)pageNumber; // zero-based pageNumber
- (void)tileMenu:(MGTileMenuController </em>)tileMenu didSwitchToPage:(NSInteger)pageNumber; // zero-based pageNumber
And corresponding notifications:</p>

<p>1
2
3
4
// The following notifications have a user info key &ldquo;MGPageNumber&rdquo; with an NSNumber (integer, zero-based) value.</p>

<h1>define MGPageNumberKey @&ldquo;MGPageNumber&rdquo;</h1>

<p>extern NSString <em>MGTileMenuWillSwitchToPageNotification; // menu will switch to the given page
extern NSString </em>MGTileMenuDidSwitchToPageNotification; // menu did switch to the given page
Rule 25: Test the hell out of it</p>

<p>Finally, something we all already know. Software engineering and professionalism 101: make sure it actually works.</p>

<p>Whether testing means formal TDD is up to you, but testing itself isn’t optional. Every optional delegate method. Every posted notification. Every point of customisation, in every possible combination. Components provide a thousand opportunities for subtle issues.</p>

<p>There will be bugs. Find them and fix them first. If you’re pushed for time, cut a feature and debug instead. Thou shalt suffer no bugs to ship.</p>

<p>Final thoughts</p>

<p>I’ve formulated the above rules by learning the hard way, through years of making mistakes while creating components and their APIs. I do try to practise what I preach, though inevitably there will be a hundred examples of where I haven’t.</p>

<p>Whilst not all rules apply to all situations, and no rule applies in every case, following as many of these as you can will give you a better chance of producing flexible, well-designed, reusable components for yourself and others to enjoy.</p>

<p>You may want to grab a quick summary of the rules, as shown below; I have the full-size version hosted on Flickr.</p>

<p>API Design for iOS components
If you’re interested in releasing your components for others to use, as I did with MGTileMenu, you may also want to read my article on releasing open source code, which touches on some of these points and also talks about your README file, license choice, and related matters.</p>

<p>I hope you’ve enjoyed this article. If you did, perhaps you’d consider buying a non-attribution license for some of my open source components, or supporting future articles on this blog (and future source code releases) via a donation.</p>

<p>PayPal — The safer, easier way to pay online.
I’d truly appreciate it.</p>

<p>For more about software and user experience design, along with a multitude of other topics, you should follow me (@mattgemmell) on Twitter. You can also hire me for your own projects.</p>

<p>Now go and make great software.</p>

<p>Twitter Facebook Google+ Email
My writing is supported by readers like you.
Any contribution helps enormously.
My thanks to SupportKit for sponsoring my writing this week.
(Interested in sponsorship? Read this.)
« MGTileMenuiPhoto iPad tooltips PSD »
Copyright © 2014 Matt Gemmell Twitter Archive RSS</p>

		
		
	</div>

</article>


    <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
	<div class="meta">
		<div class="date">








  


<time datetime="2014-09-14T19:47:54+08:00" data-updated="true" itemprop="datePublished"></time></div>
		<div class="tags">


	<a class='category' href='/blog/categories/fan-yi/'>翻译</a>


</div>
		
		
          | <a href="/blog/2014/09/14/zao-gao-de-ce-shi/#comments">Comments</a>
         
	</div>
	<h1 class="title" itemprop="name"><a href="/blog/2014/09/14/zao-gao-de-ce-shi/" itemprop="url">糟糕的测试</a></h1>
	<div class="entry-content" itemprop="articleBody">
		<p>时至今日，我写自动化测试也已经有些年头了，我不得不承认当它能使代码更容易维护，因此我依然对这项技术着迷。本文中，我希望分享一些我的经验，以及我从他人或自己的一次次尝试中所吸取的教训。</p>

<p>这些年，我听到了许多关于写自动化测试的好的 (以及不好的) 理由。从积极的方面来说，写自动化测试能够:</p>

<ul>
<li>使重构更简单</li>
<li>避免代码恶化</li>
<li>提供了可执行的说明和文档</li>
<li>减少了创建软件的时间</li>
<li>降低了创建软件的代价</li>
</ul>


<p>的确，你可以说这些都是对的，但是我想提出一个关于这些理由的另一个视角 —— 一个统一的视角</p>

<blockquote><p>自动化测试唯一的理由是它让我们能在将来修改我们的代码。</p></blockquote>

<p>换句话说:</p>

<blockquote><p>一个测试能够体现回报价值的时候仅仅是当我们想修改我们的代码的时候。</p></blockquote>

<p>让我们看一看这个经典论断是如何支持我们前面提到的理由的:</p>

<ul>
<li>使重构更简单 —— 你可以自信的修改实现细节，而不用去触及公有 API。</li>
<li>避免代码恶化—— 恶化在什么时候发生？在你修改代码的时候。</li>
<li>提供了可执行的说明和文档 —— 你在什么时候更想知道软件实际上是如何工作的？在你想修改它们的时候</li>
<li>减少了创建软件的时间 —— 怎么减少时间的？是通过更快速地修改你的代码，出错时测试会自信地告诉你哪里出错了</li>
<li>降低了创建软件的代价 —— 好吧，时间就是金钱，我的朋友</li>
</ul>


<p>是的，上面所有的理由在某些方面是对的，但是这些理由适用于我们开发者的就是自动化测试能够让我们修改代码。</p>

<p>注意，我在这里<strong>不会写</strong>关于测试的设计所能得到的反馈，比如 TDD。那可以成为一个单独的话题。我们将要谈论的测试是已经写好的测试。</p>

<p>看起来好像写测试和<strong>如何</strong>写测试应该以<strong>修改</strong>作为动机。</p>

<p>一个简单的考虑这个问题的方法是在写测试的时候，向你的测试提出下面两个问题:</p>

<p>“如果我修改了我的生产代码，测试是会失败 (还是通过) 呢?”</p>

<p>“那是一个让测试失败 (或者通过) 的好的理由么?”</p>

<p>如果你发现那是一个让测试失败 (或者通过) 的不好的理由，那么请修正它。</p>

<p>那样，将来你修改你的代码的时候，你的测试只会因为好的理由而通过或者失败，这会比因为不好的理由而失败的古怪的测试得到的回报要好。</p>

<p>现在，你可能仍然会问：“什么才是最重要的？”</p>

<p>让我们用另一个问题来回答这个问题：当我们修改代码的时候，测试为什么会出错？</p>

<p>我们都认同的一个观点是我们进行测试的主要原因是为了能够轻松地修改代码。如果是那样的话，那些失败的测试是如何帮助我们的？那些失败的测试除了是噪音之外什么也不是 —— 它们甚至会阻碍着我们完成工作。那么，怎样做测试才能帮助我们呢？</p>

<p>这取决于我们修改代码的理由。</p>

<h3>修改代码的行为</h3>

<p>首先，起点必须是测试全部是绿色的，也就是说所有的测试都已经通过。</p>

<p>如果你想通过修改代码来修改它们的行为 (也就是，修改代码<strong>做的事情</strong>)，你需要：</p>

<ol>
<li>找到定义当你想要修改的前行为的测试。</li>
<li>修改这些测试来满足新的期望的行为。</li>
<li>运行测试，查看那些被修改的测试是否失败了。</li>
<li>更新你的代码，使得所有的测试重新通过。</li>
</ol>


<p>在这一过程的结尾，我们又回到了起点——所有的测试都通过了，如果需要，我们已经准备好了再次开始。</p>

<p>因为你知道哪些测试失败了以及哪些代码的修改使得它们又通过了，你会很有信心，因为你只修改了你想要修改的部分。这就是自动化测试如何帮助我们通过修改代码来修改代码的行为的。</p>

<p>注意，看到一个测试失败是正常的，因为它是我们正在更新的行为相对应的测试。</p>

<h3>重构：修改代码的实现 —— 保持行为不变</h3>

<p>同样，起点应该是测试全是绿色的。</p>

<p>如果希望修改一段代码的实现让它变得更简单，高效，易于扩展等等 (也就是说，修改<strong>怎么做</strong>，而不是<strong>做什么</strong>)，应该遵循接下来的原则：</p>

<p>在不触及测试的前提下修改你的代码。</p>

<p>当修改后的代码已经简单、快速、更灵活时，你的测试应该仍然是绿色的。在重构的时候，测试应该只在代码出错的时候失败，例如修改了代码的外部行为。当发生这种情况时，你应该退回到那个错误然后回到绿色的状态</p>

<p>因为你的测试总是在绿色的状态，你知道你没有破坏任何事情。这就是自动化测试如何让我们修改我们的代码的方式。</p>

<p>在这种情况下，看到测试失败是不应该的。因为这意味着：</p>

<ul>
<li>我们无意识地修改了代码的外部行为。庆幸的是，我们的测试帮助了我们发现这些错误。</li>
<li>我们没有修改代码的外部行为。太不幸了，这才是最大的麻烦。</li>
</ul>


<p>我希望测试在上面的情形下能够帮助我们。所以让我们来看一些具体的能让我们的测试更有效的 tips。</p>

<h2>优秀实践入门</h2>

<p>在讨论如何写测试之前，我想迅速地回顾一些优秀实践。有 5 条被认为是每个测试都应该遵守的基本原则。便于记忆这 5 条规则的缩写是: F.I.R.S.T.</p>

<p>测试应该：</p>

<ul>
<li>很快速(<strong>F</strong>ast) —— 测试应该能够被经常执行。</li>
<li>能隔离(<strong>I</strong>solated) —— 测试本身不能依赖于外部因素或者其他测试的结果。</li>
<li>可重复(<strong>R</strong>epeatable) —— 每次运行测试都应该产生相同的结果。</li>
<li>带自检(<strong>S</strong>elf-verifying) —— 测试应该包括断言，不需要人为干预。</li>
<li>够及时(<strong>T</strong>imely) —— 测试应该和生产代码一同书写。</li>
</ul>


<p>更多关于这些规则的内容，你可以阅读 Tim Ottinger 和 Jeff Langr 的<a href="http://pragprog.com/magazines/2012-01/unit-tests-are-first">这篇文章</a>。</p>

<h2>坏的实践</h2>

<p>如何将测试的结果收益最大化？一言以蔽之:</p>

<blockquote><p>不要将测试和实现细节耦合在一起</p></blockquote>

<h3>不要测试私有方法</h3>

<p><a href="http://shoulditestprivatemethods.com/">说得够多了。</a></p>

<p><a href="http://shoulditestprivatemethods.com/">私有方法意味着私有。如果你感到有必要测试一个私有方法，那么那个私有方法一定含有概念性错误，通常是作为私有方法，它做的太多了，</a>  从而违背了<a href="http://www.objectmentor.com/resources/articles/srp.pdf">单一职责原则</a></p>

<p>今天：假设你的类有一个私有方法。它做了太多的事情，所以你决定测试它。你仅仅为了测试，就让那个方法变成公有的。它本来只被同一个类的其他的公有方法在内部使用。然后你为这个私有 (从技术上来说现在公有了的) 方法编写测试。</p>

<p>明天：因为需求上的一些变化 (这完全是有可能的)，你决定修改这个方法。你发现一些同事在其他的类中使用了这个方法，因为他们说 “这个方法做了我想要的事情”。毕竟，它是公有的，不是么？这个私有方法不是公有 API 的一部分。你要想修改这个方法就不得不破坏你同事的代码。</p>

<p>应该做什么：将私有方法抽离到一个单独的类中，给这个类一个定义良好的约定，然后单独地测试它。当其他的测试代码依赖这个新的类的时候，如果有必要的话，你可以进行<a href="http://objccn.io/issue-15-5/">置换测试</a>。</p>

<p>那么，我们如何测试一个类的私有方法呢？通过这个类的公有 API。永远通过公有 API 测试你的代码。程序的公有 API 定义了一个约定，它是一组关于你的程序对应于不同输入时定义良好的一组期望。私有 API (私有方法或者整个类) 并没有定义约定，并且可以不经通知自行修改，所以你的测试 (或者你的同事) 不能依赖于它们。</p>

<p>通过这种方法测试你的私有方法，你可以自由地修改你的 (真正的) 私有代码，并且通过划分成只做一件事情，并经过正确测试的小的类，来提升代码的设计。</p>

<h3>不要 Stub 私有方法</h3>

<p>Stub 私有方法和测试私有方法具有相同的危害，更重要的是，stub 私有方法将会使程序难以调试。通常来说，用于 stub 的库会依赖于一些不寻常的技巧来完成工作，这使得发现一个测试为什么会失败变的困难。</p>

<p>同样，当我们 stub 一个方法的时候，我们必须依据它做出的约定来进行。但是私有方法没有指定的约定的 —— 毕竟，这也是为什么它们是私有的原因。由于私有方法的行为可以不经通知自行修改，你的 stub 可能与实际情况背道而驰，但是你的测试<strong>仍然会通过</strong>。这是多么的可怕啊，让我们来看一个例子：</p>

<p>今天：一个类的公有方法依赖于该类的一个私有方法。这个私有方法 <code>foo</code> 永远不会返回空。为公有方法编写的测试为了方便起见，我们 stub 出了私有方法。当 stub <code>foo</code> 方法的时候，你永远不会考虑到 <code>foo</code> 返回为空的情况，因为现在这种情况永远不会发生。</p>

<p>明天：这个私有方法被修改了，现在它返回空了。它是一个私有方法，所以这没什么问题。为公有方法编写的测试不会相应地被修改 (“我正在修改一个私有方法，所以我为什么要更新我的测试？”)。公有方法现在在私有方法返回空的情况下会出错，但是测试仍然会通过！</p>

<p>这实在太可怕了。</p>

<p>应该做什么：由于 <code>foo</code> 做的事情太多了，所以应该将它抽离至一个新的类，然后单独地测试它。然后，在测试的时候，为那个新类提供一个<a href="http://objccn.io/issue-15-5/">置换</a>。</p>

<h3>不要 Stub 外部库</h3>

<p>第三方代码不应该在你的测试中直接出现。</p>

<p>今天：你的网络部分的代码依赖于著名的 HTTP 库 <code>LSNetworking</code>.为了避免使用实际的网络 (为了让你的测试更快速更可信)，你 stub 了那个库中的方法 <code>-[LSNetworking makeGETrequest:]</code>，没有通过实际的网络合适地替代了它的行为 (它通过一个封装好的响应调用了执行成功的回调)。</p>

<p>明天：你需要使用一个替代品来取代 <code>LSNetworking</code> (可能是 <code>LSNetworking</code> 已经不再维护或者是你需要换成一个更先进的库，因为它有很多你需要的新特性等等)。这是一次重构，所以你不应该修改测试。你替换了库。你的测试会失败，因为依赖的网络没有被 stub (<code>-[LSNetworking makeGETrequest:]</code>不会被调用)。</p>

<p>应该做什么：测试中，依靠 stubbing 伞 (umbrella stubbing) 来替代那个库的全部功能。</p>

<p>stubbing 伞 (一个我刚刚发明的术语) 包括了对于所有你的代码可能用到的方式 &ndash; 不管事现在还是将来 &ndash; 的 stub。它们可以通过良好声明的 API 完成一些任务，而不去关心实现的细节。</p>

<p>正如上面的那个例子，你的代码今天可能依赖于 &ldquo;HTTP 库 A&#8221;，但是还是有别的可能的方式发起 HTTP 请求，不是么？比如 &#8220;HTTP 库 B&#8221;。</p>

<p>举个例子，我的一个开源项目 <a href="https://github.com/luisobo/Nocilla">Nocilla</a> 就为网络代码提供 stubbing 伞的解决方案。通过 <a href="https://github.com/luisobo/Nocilla">Nocilla</a> 你可以不依赖任何 HTTP 库，以声明的方式 stub HTTP 请求。<a href="https://github.com/luisobo/Nocilla">Nocilla</a> 可以 stubbing 的任何一个 HTTP 库，所以你不会将测试和实现细节耦合在一起。这使得你能够在不修改测试的情况下切换网络框架。</p>

<p>另一个例子是 stub 日期，在大多数编程语言中都有很多中方法获取当前时间，但是像 <a href="https://github.com/tuenti/TUDelorean">TUDelorean</a> 这样的库可以 stub 每一个与日期相关的 API，所以你可以模仿一个不同的系统日期用来测试。这让你你不用修改测试就可以重构不同的日期 API 的实现细节。</p>

<p>除了 HTTP 和日期，在拥有各种各样 API 的其他领域，你可以用类似的方式来实现 stubbing 伞，或者你可以创建你自己的开源解决方案并分享到社区，这样其他人就可以正确地编写测试了。</p>

<h3>正确地 Stub 依赖</h3>

<p>这部分和前一点关系密切，但是这部分的情况更普遍。我们的生产代码通常依赖于某些事情的完成。比如，一个依赖能够帮助我们查询数据库。通常这些依赖提供了多种方法来实现相同的事情，或者说至少是实现相同的外部行为；在我们的数据库的例子中，你可以使用 <code>find</code> 方法通过 ID 来获取一条记录，或者使用 <code>where</code> 子句获取相同的记录。当我们仅仅 stub 可能的机制中的一个的时候，问题就出现了。如果我们仅仅 stub 了 <code>find</code> 方法 (我们的生产代码使用的机制)，但是没有 stub 其他的可能性，比如 <code>where</code> 子句，当我们决定使用 <code>where</code> 子句取代 find 方法来重构我们的实现的时候，我们的测试就会失败，即使代码的外部行为并没有修改。</p>

<p>今天：<code>UsersController</code> 类依赖于 <code>UserRepository</code> 类从数据库中取得用户。你正在测试 <code>UsersController</code> 并且你为了以确定的方式更快地运行，你 stub 了 <code>UsersRepository</code> 的 <code>find</code> 方法，这实在是太棒了。</p>

<p>明天：你决定使用 <code>UsersRepository</code> 的新的可读性更高的查询语法来重构 <code>UsersController</code>，因为这是一次重构，所以不应该触及测试。为了找到感兴趣的记录，你使用了可读性更高的 <code>where</code> 方法更新了 <code>UsersController</code>。现在你的测试会失败，因为测试 stub 了 <code>find</code> 方法，但是没有 stub <code>where</code> 方法。</p>

<p>stubbing 伞在某些情况下能帮上忙，但是对于 <code>UsersController</code> 类的这种情形，没有可以替代的库能够从我的数据库中获取我的用户。</p>

<p>应该做什么：以测试为目的，为同一个类创建可替代的实现，并将它作为<a href="http://objccn.io/issue-15-5/">置换</a>来使用。</p>

<p>继续我们的例子，我们应该提供一个 <code>InMemoryUsersRepository</code>。这个在内存中的替代方案，除了它为提高测试速度而把数据保存在内存中之外，它应该遵守原始的 <code>UsersRepository</code> 类的每一个单一方面的约定。这意味着，当你重构 <code>UsersRepository</code> 的时候，你使用在内存中这个版本做了同样的事情。为了让它更清楚：是的，现在你不得不为同一个类维护两套不同的实现。</p>

<p>现在你可以将这个轻量级的版本的依赖作为置换对象提供给测试。好的事情是这是一个完整的实现，所以当你决定将实现从一个方法移动到另一个方法 (在我们的例子中是从 <code>find</code> 移动到 <code>where</code>) 的时候，正在使用的置换对象将会支持新的方法，并且当重构的时候，测试也不会失败。</p>

<p>维护一个类的另一个版本没有什么问题。根据我的经验，它最终只会需要很少的努力，就能得到很大的回报。</p>

<p>你同样可以将类的轻量级版本作为生产代码的一部分，就像 Core Data 使用栈的内存版本一样。这样做可能对某些人有作用。</p>

<h3>不要测试构造函数</h3>

<p>构造函数定义的是实现细节，你不应该测试构造函数，这是因为我们认同测试应该与实现细节解耦这一观点。</p>

<p>而且，构造函数不应该包含行为，所以没有值得测试的东西。这是因为我们认同测试应该只对代码的行为进行这一观点。</p>

<p>今天：你有一个 <code>Car</code> 类，并包含一个构造函数。一旦一个 <code>Car</code> 被创建了，你测试它的 <code>Engine</code> 不为空 (因为你知道构造函数创建了一个新的 <code>Engine</code> 并将它赋给了变量 <code>_engine</code>)。</p>

<p>明天：<code>Engine</code> 类创建起来变得代价很高，所以你决定使用延迟初始化 (lazily initialize)，在第一次调用 <code>Engine</code> 的 <code>getter</code> 方法时才初始化 <code>Engine</code> (这是很好的)。 现在为 <code>Car</code> 类的构造函数编写的测试出问题了，即便 <code>Car</code> 类运行良好，但 <code>Car</code> 并没有包括 <code>Engine</code>。另一个可能是你的测试不会失败，因为测试包含 <code>Engine</code> 的 <code>Car</code> 类会触发 <code>Engine</code> 的延迟加载。所以我的问题是：为什么还要测试？</p>

<p>应该做什么：当使用不同的方法创建类的时候测试公有 API 的行为。一个愚蠢的例子：测试当 <code>list</code>类被创建并且没有包含条目的时候，list 类的 <code>count</code> 方法的行为。注意，你测试的是 <code>count</code> 的行为而不是构造函数的行为。</p>

<p>思考一下，类含有多个构造函数的情形，这可能意味着你的类做了太多事情了。试着将它们拆分成更小的类，但是如果有足够充分的理由使你的类含有多个构造函数，那么依然遵循同样的建议。保证你的测试的是那个类的公有 API。在这种情况下，使用每一个构造函数去测试 (也就是说，当类处在一种初始化状态下时，它的行为就是那种状态下的；当类处在另一种初始化状态下时，它的行为是另一种状态下的)</p>

<h2>结论</h2>

<p>编写测试是一项投资 —— 我们需要花时间编写和维护它们。我们可以证明这种投资有回报的唯一方法就是我们期望节省时间。将实现细节和测试耦合在一起会减少测试带来的回报，使得那些投资变得不合算，甚至在某些情况下变得一文不值。</p>

<p>在编写测试、重构以及修改系统行为的时候，检查你的测试在面对错误的原因时是失败还是通过，然后退一步问问自己，那些测试是否能够最大化你投资的成果。</p>

<hr />

<p><a href="http://objccn.io/issue-15">话题 #15 下的更多文章</a></p>

<p>原文 <a href="http://www.objc.io/issue-15/bad-testing-practices.html">Bad Testing Practices</a></p>

		
		
	</div>

</article>

</div>
<nav id="pagenavi">
    
    
    <div class="center"><a href="/blog/archives">Blog Archives</a></div>
</nav></div>
			</div>
			<footer id="footer" class="inner"><p>
  Copyright &copy; 2014 - Onet away -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

Design credit: <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a></footer>
			<script src="/javascripts/slash.js"></script>
<script type="text/javascript">
var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F6a5ef2081fb49e0f52664922edcbbe58' type='text/javascript'%3E%3C/script%3E"));
</script>

<script src="/javascripts/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
	$('.fancybox').fancybox();
})(jQuery);
</script> <!-- Delete or comment this line to disable Fancybox -->




	<script type="text/javascript">
		var _gaq = _gaq || [];
		_gaq.push(['_setAccount', 'UA-54780065-1']);
		_gaq.push(['_trackPageview']);

		(function() {
			var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
			ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
			var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
		})();
	</script>




		</div>
	</div>
</body>
</html>
