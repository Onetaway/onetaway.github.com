---
layout: post
title: "API设计"
date: 2014-09-18 15:33:15 +0800
comments: true
categories: 翻译
---

##API设计

本文翻译自 Matt Gemmell 的经典博文，想阅读英文原版的同学请直接点击[这里](http://mattgemmell.com/api-design/)。下面开始正文内容。

我在开发中做的最多的一件事就是为可重用的组件设计 API。这些组件通常都是给 iOS 用的(尽管有时候，它们也适用于 OS X)，通常是 GUI 控件或者是某种视图。

这些年我设计了许多组件 API，包括像苹果的客户端，因此我学到了很多这方面的东西。我也定期发布[开源组件](http://mattgemmell.com/source/)，我收到的反馈帮助我形成了 API 设计的准则，我想与你们分享这些。

这是一个重要的话题，无论你是一个开源软件的贡献者，还是一个工作在大型项目团队里的成员，或者你仅仅是编写自己的软件。就像第一次启动应用程序的经历一样，你的 API 会给使用你代码的开发者留下第一印象，这会在很大程度上决定他们是使用你的 API 还是直接扔掉。

in a way that’s specific to the popular platforms.

API 是开发者的用户体验(UX)。令我惊讶的是，在这方面没有很多资料。

我打算使用我最新发布的开源 GUI 组件 [MGTileMenu](http://mattgemmell.com/mgtilemenu/) 作为例子，来介绍这些原则。如果你喜欢的话，你可以在[这里](http://mattgemmell.com/mgtilemenu/)阅读关于 MGTileMenu 的一切东西。

###理想的状态

API 设计和用户界面以及用户体验设计非常相似。你的目标听众具有不同的需求和特性，但是归根到底他们也只是希望把事情完成的人。除了友好的、可用的 app UI，你还需要尽力让你的 API：

1. 直观的
2. 宽容的
3. 光滑的

因为软件的任何一部分都是设计给人使用的，所以我们不得不考虑用例。我们必须要让需要经常做的事情变得简单，同时没有过多的配置。默认的行为应该和原来一样有用，且容易选择。软件应该是可发现的，并且应该允许用户从已知的范式中生成新的东西。这些准则和我们在创建 UI 的时候是一样的

###开发者的接口

开发者和组件打交道主要是通过下面这四个显示的方式：

1. 类**接口**：它揭示了属性和方法。
2. 相关的**代理协议**
3. 合适的**数据源协议**
4. 已提供的**通知**

我们必须明智且审慎地设计这些。当你在思考 API 的时候，有两个关键的问题：

* 控件是什么？

这影响着接口和便捷方法。它是一个按钮？或者是一个滚动条？你的接口是很明显的。你的便捷方法将会遵循控件的标准语意。

* 控件像什么？

这影响着代理、数据源模型以及通知。如果它是一种新的控件，那它本质上有和其他控件相似的地方么？一个大纲视图是一个线性表。一个日历小工具是一个日期选择器。命令的集合以统一的表现形式显示在菜单栏里。

我们的核心目标是同现有的组件和模型保持一致，只有这样，我们才能将不熟悉的控件转换为开发者已经熟知的东西。尽量在任何地方使用标准的 API，模型和模式。熟悉感和直觉在代码级的重要性与在用户级的重要性一样。


让我们看一下上面提到的组件 API 中的四个要素。

###类的接口

这里是 [MGTileMenu 的接口文件](https://github.com/mattgemmell/MGTileMenu/blob/master/MGTileMenu/MGTileMenuController.h)。

在我们开始讨论特定的接口之前，我们先来看看一些重要的准则。

##准则1：使用本平台语言

在 API 设计中我见到的最普遍的错误是使用*其他平台的习惯*。API 属于一个平台和一个开发者生态系统。你不能使用你曾经熟悉的与本平台不同的平台的习语和架构，那样做，只会污染你当前的代码，并且降低后继开发者生产力。

*在编码之前，学习你的目标平台的语言习惯*。比如，在 iOS 或者 OS X 上，不要为控制流使用异常。以合适的方式命名你的方法(这通常表示方法名应该*充分的冗长*，但是同样表意也很*清晰*)。

The vocabulary and the grammar are indivisible, and you’re either developing for a given platform or you’re not.

学习什么是协议，什么是代理，什么是类别。在你的代码中使用那些术语。学习构造函数和析构函数相关的命名模式。遵守本地内存管理规则。词汇和语法是不可分割的，

##准则2：在设计上解耦

任何组件都应该被设计成与你创建的项目相互解耦，并且如果它不是一个 GUI 组件或者视图，至少在默认情况下应该显示*某些东西*。用现有的框架类作为指南，在合适的地方，保持与代理协议，设计和命名良好的 API 方法以及通知的松耦合。

一个显而易见但却行之有效的方法是为每一个组件创建一个新工程，然后独立地去开发组件。强制你使用你自己的 API。抵制将不相关的类耦合在一起的诱惑。以你期望的方式继续。

With that said,让我们来谈谈类接口的合适性。初始化方法是接口中最重要的部分之一，因为它们是人们如何开始使用你的组件的地方。你的类的初始化配置需要包含明确的、必要的设置。所以，一个显而易见的准则是：

##准则3：必要的设置应该是初始化函数的参数

如果某些东西需要被设置，别想着以后再设置，现在就设置它，立刻马上，如果你没有得到想要的东西，那么就返回 nil。

    1 -(id)initWithDelegate:(id<MGTileMenuDelegate>)theDelegate; // required parameter; cannot be nil.

##准则4：允许获取初始化函数的参数

and note if they might have been massaged in any way (sanitised, or otherwise modified).

这是前一个准则的推论：记住不要吞没这些参数。通过 properties 来获取它们，

    1 @property (nonatomic, weak, readonly) id<MGTileMenuDelegate> delegate; // must be specified via initializer method.
    
前面这两个例子揭示了非常重要的一点。

##准则5：注释你的头文件(包括默认的)

Realistically, you won’t always provide separate, standalone documentation for a component. If you don’t provide documentation, your .h files (and demo app) are your docs. They should be suitably written, and by ‘suitably’ I mean:

实际上，

Sufficiently detailed, but no more so. Be succinct.
For professionals. Assume things that are safe to assume. Don’t waffle.
Particularly, you should briefly note default values beside properties or accessors; it’s much easier to scan those in the header file than to try to locate your initialisation code in the implementation.

    1 @property (nonatomic) CGGradientRef tileGradient; // gradient to apply to tile backgrounds (default: a lovely blue)
    2 @property (nonatomic) NSInteger selectionBorderWidth; // default: 5 pixels
    3 @property (nonatomic) CGGradientRef selectionGradient; // default: a subtle white (top) to grey (bottom) gradient




Rule 6: Get up and running in 3 lines

Your class should be designed so that it requires minimal code to integrate (delegate/data-source protocol included, about which more later). Excluding delegate methods, you should aim to make it usable at least for testing purposes with only 3 lines of code.

Those lines are:

1. Instantiate it.
2. Basically configure, so it will show and/or do something.
3. Display or otherwise activate it.

That should be it. Anything substantially more onerous is a code smell. Here are the relevant lines from MGTileMenu’s demo app:

    1 // Instantiate.
    2 tileController = [[MGTileMenuController alloc] initWithDelegate:self];
    3
    4 // Configure.
    5 tileController.dismissAfterTileActivated = NO; // to make it easier to play with in the demo app.
    6
    7 // Display.
    8 [tileController displayMenuCenteredOnPoint:loc inView:self.view];


##准则7：一个臃肿的示例通常意味着一个不好的组件

Another corollary: the size of your demo harness is a quality metric for your component, where smaller is better. Demo harnesses/code should be as small and thin as possible (making suitable allowances for demos that aim to explore all of a component’s customisation or functionality).

The core required code to turn an empty Xcode app template into a demo of your app should be minimised. It’s not OK to required copy-pasted boilerplate to get your component working, and having an example of it in your demo isn’t an excuse.


##准则8：预见定制化服务的场景

My standard rule for apps is don’t give the user options. Choose sensible defaults to fit the majority, and skip the Preferences window. Good software, after all, is opinionated.

The situation is a bit different with components, because the scenarios of use aren’t as clear-cut. You can certainly make a component that only fits one specific situation, but usually we want some flexibility. You never know exactly how another developer is going to use your component, so you have to build in some generality.

It’s important to choose your customisation points carefully. It’s particularly important to consider dependencies - not in the compiling/linking sense, but rather the logical relationships between types of customisation. I approach this by trying not to think of customisation at the instance-variable level, but rather at the “aspect” level. What aspects of your component do you want to allow customisation of? Then you work out what specific properties to expose.

It’s easy to cripple a certain type of customisation by not exposing sufficient configuration points. Some examples:

1. Don’t expose width and height without considering corner radius too.
2. Don’t expose background colour without highlighted background colour.
3. Don’t expose size without spacing.


The specifics depend on the component, but just try to consider the relationships between properties, from the point of view of either appearance or functionality. Empathise with the developer. Be flexible, without abandoning the identity of the component.


    1 @property (nonatomic) BOOL dismissAfterTileActivated; // automatically dismiss menu after a tile is activated (YES; default)
    2 @property (nonatomic) BOOL rightHanded; // leave gap for right-handed finger (YES; default) or left-handed (NO)
    3
    4 @property (nonatomic) NSInteger tileSide; // width and height of each tile, in pixels (default 72 pixels)
    5 @property (nonatomic) NSInteger tileGap; // horizontal and vertical gaps between tiles, in pixels (default: 20 pixels)
    6 @property (nonatomic) CGFloat cornerRadius; // corner radius for bezel and all tiles, in pixels (default: 12.0 pixels)


Let common sense be your guide. Decide what options will serve 70% or so of the usage situations you can think of, and provide those options. Let your delegate methods and code structure serve the rest.


##准则9：更多的属性，更少的行为

There’s a particular pattern that keeps cropping up in components that I like - some of which are from standard frameworks, some open source from third parties, and some even my own. It’s a ratio of the number of properties (or accessors, or customisation points) on a component, to the number of “do stuff” methods (i.e. all the other stuff, from initializers to state-updating).

It’s pretty much always more properties, and fewer ‘actions’ (again, that’s not actions in the Interface Builder sense). MGTileMenu has an initializer, and four actual for-public-use methods (one of which is a convenience that calls another). In terms of customisation points, it has four times as many. I think that’s a good ratio, and leads to components that are both concise in actual functionality, but also flexible in customisation.

    1 - (id)initWithDelegate:(id<MGTileMenuDelegate>)theDelegate; // required parameter; cannot be nil.
    2 - (CGPoint)displayMenuPage:(NSInteger)pageNum centeredOnPoint:(CGPoint)centerPt inView:(UIView *)parentView; // zero-based pageNum
    3 - (void)dismissMenu;
    4 - (void)switchToPage:(NSInteger)pageNum; // zero-based pageNum


##准则10：在你的控件中使用控件


A great way to simplify both the API and implementation of your component is to use existing controls in your implementation. A unified presentation doesn’t meant that you can’t build something out of pre-existing components (indeed, that’s one of the basic principles of good software engineering).

Consider how UITableViewCell and UIButton have simple APIs because they use sub-controls such as UIImageViews and UILabels. You can, and should, do that too - and if appropriate, expose the corresponding sub-controls to keep your class interface concise and consistent.

In MGTileMenu, for example, the tiles are regular UIButtons (not even subclasses). This drastically simplified the implementation compared to drawing the tiles within a single custom view, tracking input events, and supporting accessibility.


##准则11：让你方便就是让我方便

You’ll naturally add convenience methods during implementation, and the instinct is to keep them private. Instead, consider whether you can expose them for use by those who integrate your component into their own apps.

Whatever made it more convenient for you to add a method or function may apply to those developers too.

For example, in MGTileMenu I created these convenience functions:

    1 CGRect MGMinimallyOverlapRects(CGRect inner, CGRect outer, CGFloat padding);
    2
    3 CGGradientRef MGCreateGradientWithColors(UIColor *topColorRGB, UIColor *bottomColorRGB); // assumes colors in RGB colorspace





The first helps me shift a tile menu so that it’s fully visible within its parent view (which might be handy for another developer, if they’re providing ancillary UI related to the menu), and the second returns a Core Graphics gradient from two UIColors, which I used when setting a default background for the tiles (and another developer may find handy when implementing MGTileMenu’s delegate protocol, to give tiles custom gradients).

Rule 12: Magic is OK. Numbers aren’t.

Sooner or later, you’ll put magic into your component. Hopefully there’ll be plenty of the Steve Jobs type of intuitive, delightful, empowering magic, but what I’m talking about is things like numbers and other values that have special meaning in your code. A common example is -1, to indicate a unique thing in a set, or a special situation.

It’s fine. It’s genuinely OK to do that. What’s not OK, though, is needlessly putting mysterious raw values throughout your code, and it’s especially not OK to expose that in the API. If you’re exposing magic, dress them up for consumption. Use #defines or a constant or something. Just make them presentable and understandable.

    1 // Used for the page-switching tile in methods expecting a tile-number.
    2 #define MG_PAGE_SWITCHING_TILE_INDEX -1


Delegate and data-source protocols

Delegate protocols are fantastic. They’re an easy, familiar and flexible way to embrace the MVC pattern, and they reinforce good habits of loose coupling and judicious API design.

Here’s MGTileMenu’s delegate protocol.

There are classic delegate and data-source protocols that we can draw on for almost any component. If you’re displaying data, the One True Data-Source Protocol is likely to be something very close to:

How many things do I have?
What’s the value for property Y of thing X?
Similarly, in almost any situation, the One True Delegate Protocol is likely to take the form:

Should this thing do that?
This thing is about to do that.
This thing just did that.
This is also known as the Should, Will, Did protocol pattern, and it ties neatly in with the Will-Did notification pattern too, about which more later.

Let me mention something you might find controversial: I find it perfectly acceptable to conflate the delegate with the data-source (i.e. combine them into a single protocol). I do it with MGTileMenu and several other components, for example.

I fully accept the principle of separating them, and I can think of many cases where you’d want to keep them separate. Apple keeps them separate too, generally. That’s fine.

In my experience, though, in most cases it’s fine to combine them. Most people handle data-source methods and delegate methods in the same place. I’ve never had a complaint about unifying those protocols, and I can scarcely remember a situation where even existing separate protocols were handled in different places.

If you care about purity, or have a need to separate delegate from data-source, then obviously you should do so. I just don’t think you need to feel bad if you combine them.

Rule 13: Limit ‘required’ delegate methods
##准则13：限制'required'代理方法

Be very careful when choosing which of your delegate methods are required. Too many required methods tends to indicate:

1. Poor choice of default behaviour.
2. Too much of your own politics are in your code.

A well-designed component should need very, very few required delegate methods - just the bare minimum to do whatever it does. Choose carefully. Equally, remember that it’s easy to add optional methods later, but it’s hard to turn optional ones into required ones (people will complain, and rightly so).

MGTileMenu has five required methods, four of which are data-source methods:

    1 - (NSInteger)numberOfTilesInMenu:(MGTileMenuController *)tileMenu; // in total (will be shown in groups of up to 5 per page)
    2 - (UIImage *)imageForTile:(NSInteger)tileNumber inMenu:(MGTileMenuController *)tileMenu; // zero-based tileNumber
    3 - (NSString *)labelForTile:(NSInteger)tileNumber inMenu:(MGTileMenuController *)tileMenu; // zero-based tileNumber
    4 - (NSString *)descriptionForTile:(NSInteger)tileNumber inMenu:(MGTileMenuController *)tileMenu; // zero-based tileNumber




The first two follow the One True Data-Source Protocol. The third and fourth do too, but they also expose my politics: I think that software should be accessible, and I’m forcing you to supply a label and hint for each tile for VoiceOver to read. I’m comfortable with it.

There’s also one delegate method proper:

    1 - (void)tileMenu:(MGTileMenuController *)tileMenu didActivateTile:(NSInteger)tileNumber; // zero-based tileNumber

That one is required because it’s how you find out that a tile was activated. If you’re not willing to pay attention to that, MGTileMenu will do nothing useful, and you might as well not be using it at all. So, it’s required.

Rule 14: Design for accessibility

Following immediately on from the last rule: make things accessible. Don’t tack it on at the end, either: design for accessibility from the start. If you follow the “use controls in your controls” rule, you probably get this almost for free.

Delegate (or rather, data-source) methods, as shown above, are a great place to twist the arm of another developer to make them at least provide something for VoiceOver. And if you can automatically repurpose something visual (like a displayed text label) as a VoiceOver label, so much the better (again, in most cases VoiceOver already handles this for you).

Be socially conscious. Make it hard not to support accessibility. I also wrote an article about supporting VoiceOver in iOS apps, which Apple recommends to companies who contact them about accessibility programming. I recommend it too, but then I wrote it, so you’d expect that.

##准则15：为参数使用语意对象

This doesn’t just apply to protocols, but protocols are where it’s particularly important. Use actual, first-class, semantically-appropriate objects for data, even if it’s more hassle for you to work with in your implementation.

If you’re asking for a date, don’t accept numbers - get an actual NSDate object. There are objects or structures for just about everything, and you should use them as intended. Create a class if you need to (you probably won’t need to).

The one standard exception, of course, is indices - there’s no reason for them to be anything but primitives, since NSNumber adds nothing that’s semantically important enough to offset the bundling/unbundling inconvenience.

Rule 16: Enhance the API if semantics don’t fit

I see this all the time. I mentioned earlier how you can think of almost any new, custom control as being substantially like something that already exists (often, it’s like the already-existing thing that you’re using behind the scenes for your implementation).

That’s great, and you’re very clever, but semantics trump similarity. It’s absolutely fine (and wonderful) to layer a new API on top of an existing one, in order to make the semantics fit. For example:

* A contact list implemented with a table should have a contacts-related API
* A month-view calendar implemented with a grid should have a date-related API

And so forth. Don’t force yourself (or other developers) to constantly be mentally converting between an abstract implementation API and the actual semantics of the component - make the API reflect the actual purpose of the component instead.

MGTileMenu’s delegate protocol does that by treating the menu not as a collection of UIButtons (the implementation), but rather as a unified menu, with numbered tiles each of which have relevant display properties.


##准则17：高亮是有趣的

I learned this one by having to go back and add new delegate methods and notifications to APIs I thought were finished. For interactive controls, highlighting is interesting. By ‘interesting’, I mean of potential significance to the surrounding app.

Any control will inform the app (in one sense or another, perhaps just by calling an action method) when it has been fully triggered, but comparatively few will notify when they’ve been visually highlighted (selected, pressed) or unhighlighted without being triggered. It turns out that that’s actually pretty important. The app might want to:

1. Add, remove or reposition ancillary UI.
2. Update some other part of its display.
3. Offer some contextual help.
4. Some other thing you can’t possibly foresee.

Highlighting is certainly an example of an optional set of delegate methods, but they’re important to have, and almost always trivial to implement.

    1 -(void)tileMenu:(MGTileMenuController *)tileMenu didSelectTile:(NSInteger)tileNumber; // zero-based tileNumber
    2 -(void)tileMenu:(MGTileMenuController *)tileMenu didDeselectTile:(NSInteger)tileNumber; // zero-based tileNumber


Rule 18: Optional methods aren’t a commitment

Many of us approach optional delegate methods as an either-or situation: if you don’t implement them, you get the default behaviour, and if you do, then you’re totally responsible for what happens. That’s not ideal.

In any implementation which provides an optional delegate method, you should still fall back on the default behaviour even if the method is implemented, but doesn’t return something sensible. It sounds obvious, but it’s amazing how many components will blithely let delegate objects return any kind of craziness without sanity-checking, just because the delegate has somehow promised to behave itself by implementing the method.

I’m talking particularly about visual customisations, such as background colours or images. Consider very, very carefully whether you shouldn’t intervene in that case, and fall back upon your default appearance. Did they really want to show nothing? Does that even make sense? Will it make the control look broken? If so, step in, and serve up the default just as if the delegate method was never implemented in the first place.

Relatedly, have a documented, standard, unsurprising way to deliberately invoke the default behaviour via returning something like nil from each optional delegate method.

MGTileMenu, for example, has a relatively complex hierarchy of ways you can customise tile backgrounds. You can implement any (or all, or none) of three optional delegate methods to provide a background image, gradient or colour for each tile, in that priority order. You can also opt into the default behaviour for any tile at any time, by returning nil or NULL as is appropriate to the type.

You’ll have to try fairly hard (by returning clearColor, or an empty UIImage object) to really, really make a tile’s background completely transparent.

Rule 19: Always say who’s talking
##准则19：经常说谁在说话

This is a simple rule, and an equally simple mistake to make. In your delegate methods, always pass the sender as a parameter. Always. Even for singletons. Even for things you cannot conceive would ever be used more than once simultaneously. No exceptions.

This:

    1 - (void)tileMenu:(MGTileMenuController *)tileMenu didActivateTile:(NSInteger)tileNumber; // zero-based tileNumber

Not this:

    1 - (void)tileMenuDidActivateTile:(NSInteger)tileNumber; // zero-based tileNumber
    2 // Um, WHICH menu?


Rule 20: Put distinguishing params first in query methods

The One True Data-Source Protocol should always have query methods such that the most interesting thing goes first. The specific quality or property you’re requesting a value for. Like this:

    1 - (UIImage *)imageForTile:(NSInteger)tileNumber inMenu:(MGTileMenuController *)tileMenu; // zero-based tileNumber

不是像这样：

    1 - (UIImage *)tileMenu:(MGTileMenuController *)tileMenu imageForTile:(NSInteger)tileNumber;


The return type should flow naturally into the first part of the method name, without causing surprise. Data-source protocols often have many similarly-named methods, so keep the unique and interesting parts at the very start. Easier to read, and easier to autocomplete.

Some people have pointed out that Apple’s UITableViewDataSource protocol doesn’t do it that way, and instead puts the sender first, for example:

    1 - (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section

All I can say is: I’m aware of the difference. I stand by my argument.

##准则21：在通知函数中将发出者放在第一位

The One True Delegate Protocol, however, isn’t for queries but rather for notifications. In this situation, you put the sender first (following our “say who’s talking” rule above).

    1 - (void)tileMenu:(MGTileMenuController *)tileMenu willSwitchToPage:(NSInteger)pageNumber; // zero-based pageNumber


This follows how an interaction would go between two people having a conversation. You wouldn’t just jump in and say “She’s going to be late,” because the other person would have to ask “Who?”

Instead, you start by saying who’s talking. It’s a convention, and handily distinguishes query (data-source) from notification (delegate) methods.

##准则22：如果一个便捷方法出问题了，那就扔掉它

Having said all of the above, remember that convention and consistency must at some point bow to superior judgement - in this case, yours. If a convention is broken, skip it without worrying. Rename things, if yours is truly better.

As an example, there’s a pre-existing convention for menu controls whereby you can enable or disable menu-items via the delegate, using a method called validateMenuItem:. For the sake of consistency, I was tempted to use that same method name as part of my delegate protocol. I decided not to, because:

* It has a horrible, horrible name. “Validate”? That doesn’t say “enable” to me.
* It’s imperative, where in my case I’m really asking a question.
* It broke the naming scheme of my other delegate methods.

Instead, I went for something simpler and more understandable, if unconventionally-named:

    1 - (BOOL)isTileEnabled:(NSInteger)tileNumber inMenu:(MGTileMenuController *)tileMenu; // zero-based tileNumber

We can debate the specific wording, but if you encountered that method you’d know what it was for and how to use it right away. To me, that’s better.

##通知

Notifications are the other half of delegate protocols. My position is that, if you’re using a delegate protocol (you should, if it’s at all appropriate), then it’s incomplete until you add the notifications that naturally follow from it.

In MGTileMenu, you can find the notifications in the [interface file for MGTileMenuController](https://github.com/mattgemmell/MGTileMenu/blob/master/MGTileMenu/MGTileMenuController.h).

Rule 23: Notifications follow delegate methods
##准则23：通知遵循代理方法

There’s a natural correspondence between delegate methods (proper; not data-source methods) and notifications. You use them in the same places in your code, and for exactly the same purpose.

If you have a delegate method that tells the delegate about something happening, you should usually provide a notification for that same purpose. Take your notification-like delegate methods, remove the interrogatory ones (the should methods), and you have your list of notifications to implement.

The delegate methods’ parameters should match up with the notifications’ userInfo contents, with the obvious exception that you pass the sender as the notification’s object, rather than bundled up in the info dictionary.

代理方法：

    1 - (void)tileMenuWillDisplay:(MGTileMenuController *)tileMenu;
    2 - (void)tileMenuDidDisplay:(MGTileMenuController *)tileMenu;


以及相应的通知：

    1 extern NSString *MGTileMenuWillDisplayNotification; // menu will be shown
    2 extern NSString *MGTileMenuDidDisplayNotification; // menu has been shown

##准则24：大方地对待通知的用户信息

Give a notification the information it requires in order to be useful. Remember that notification receivers may (and almost always will) not have anything to do with the delegate or data-source chain for your component.

Ask yourself what would be useful, and provide that information. At the very least, you must ensure that all arguments provided to the corresponding delegate method are wrapped up in the userInfo object.

代理方法：

    1 - (void)tileMenu:(MGTileMenuController *)tileMenu willSwitchToPage:(NSInteger)pageNumber; // zero-based pageNumber
    2 - (void)tileMenu:(MGTileMenuController *)tileMenu didSwitchToPage:(NSInteger)pageNumber; // zero-based pageNumber

以及相应的通知

    1 // The following notifications have a user info key "MGPageNumber" with an NSNumber (integer, zero-based) value.
    2 #define MGPageNumberKey @"MGPageNumber"
    3 extern NSString *MGTileMenuWillSwitchToPageNotification; // menu will switch to the given page
    4 extern NSString *MGTileMenuDidSwitchToPageNotification; // menu did switch to the given page




Rule 25: Test the hell out of it

Finally, something we all already know. Software engineering and professionalism 101: make sure it actually works.

Whether testing means formal TDD is up to you, but testing itself isn’t optional. Every optional delegate method. Every posted notification. Every point of customisation, in every possible combination. Components provide a thousand opportunities for subtle issues.

There will be bugs. Find them and fix them first. If you’re pushed for time, cut a feature and debug instead. Thou shalt suffer no bugs to ship.

##最后的思考

I’ve formulated the above rules by learning the hard way, through years of making mistakes while creating components and their APIs. I do try to practise what I preach, though inevitably there will be a hundred examples of where I haven’t.

Whilst not all rules apply to all situations, and no rule applies in every case, following as many of these as you can will give you a better chance of producing flexible, well-designed, reusable components for yourself and others to enjoy.

You may want to grab a quick summary of the rules, as shown below; I have the full-size version hosted on Flickr.

API Design for iOS components
If you’re interested in releasing your components for others to use, as I did with MGTileMenu, you may also want to read my article on releasing open source code, which touches on some of these points and also talks about your README file, license choice, and related matters.

I hope you’ve enjoyed this article. If you did, perhaps you’d consider buying a non-attribution license for some of my open source components, or supporting future articles on this blog (and future source code releases) via a donation.

PayPal — The safer, easier way to pay online.
I’d truly appreciate it.

For more about software and user experience design, along with a multitude of other topics, you should follow me (@mattgemmell) on Twitter. You can also hire me for your own projects.

现在，去创造伟大的软件吧。
